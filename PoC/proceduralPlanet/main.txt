#include <iostream>
#include <cstdlib>
#include <GL/gl3w.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtx/transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include "main.hpp"
#include <cmath>
#include <unistd.h>

Planet::Planet() {
	modelview = glm::mat4(1.0);
	vertex_size = 3;
	vertex_number = 24;

	std::cout << "Initiate Octahedron\n";
	initVertex();

	vertexShaderID = glCreateShader(GL_VERTEX_SHADER);
	vertexShader =	"#version 130\n"
			"in vec3 vertex;\n"
			"in vec3 vertexColor;\n"
			"uniform mat4 modelview;"
			"uniform mat4 projection;"
			"void main() {\n"
			"	//gl_Position = gl_ModelViewProjectionMatrix * vec4(vertex,1.0);\n"
			"	gl_Position = modelview * projection * vec4(vertex,1.0);\n"
			"	gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;\n"
			"	gl_FrontColor = vec4(vertexColor.x+0.5, vertexColor.y+0.5, vertexColor.z+0.5, 1.0);\n"
			"}";


	fragmentShaderID = glCreateShader(GL_FRAGMENT_SHADER);
	fragmentShader =	"#version 130\n"
				"out vec3 color;\n" 
				"void main() {\n"
				"	color = gl_Color.xyz;\n"
				"}\n";

	initVBO();
	initVAO();
	this->loadVertex();
	this->loadShader();
}

Planet::~Planet() {
	glDeleteBuffers(1, &this->VBO);
}

void Planet::initVBO() {
	if(glIsBuffer(this->VBO) == GL_TRUE) {
        	glDeleteBuffers(1, &this->VBO);
	}

	glGenBuffers(1, &this->VBO);
	glBindBuffer(GL_ARRAY_BUFFER, 0);
}

void Planet::initVAO() {
	if(glIsVertexArray(this->VAO) == GL_TRUE) {
        	glDeleteVertexArrays(1, &this->VAO);
	}
	glGenVertexArrays(1, &this->VAO);
	glBindVertexArray(0);
}

void Planet::loadVertex() {
	glBindBuffer(GL_ARRAY_BUFFER, this->VBO);
		glBufferData(GL_ARRAY_BUFFER, sizeof(float) * this->vertex_number * 3 * 2 , 0, GL_STATIC_DRAW);
		glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(float) * this->vertex_number * 3, this->vertex_array);
		glBufferSubData(GL_ARRAY_BUFFER, sizeof(float) * this->vertex_number * 3, sizeof(float) * this->vertex_number * 3, this->vertex_array);
	glBindBuffer(GL_ARRAY_BUFFER, 0);

	glBindVertexArray(this->VAO);
		glBindBuffer(GL_ARRAY_BUFFER, this->VBO);
			glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(0));
			glEnableVertexAttribArray(0);
			glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(sizeof(float) * this->vertex_number * 3));
			glEnableVertexAttribArray(1);
		glBindBuffer(GL_ARRAY_BUFFER, 0);
	glBindVertexArray(0);
}

void Planet::compileShader(GLuint shaderID, char * sourcePointer) {
	glShaderSource(shaderID, 1, &sourcePointer , NULL);
	glCompileShader(shaderID);

	GLint Result = GL_FALSE;
	int InfoLogLength = 1024;
	char shaderErrorMessage[1024] = {0};

	glGetShaderiv(shaderID, GL_COMPILE_STATUS, &Result);
	
	glGetShaderInfoLog(shaderID, InfoLogLength, NULL, shaderErrorMessage);
	std::cout <<  shaderErrorMessage << "\n" ;
}

void Planet::loadShader() {
	this->compileShader(this->vertexShaderID, this->vertexShader);
	this->compileShader(this->fragmentShaderID, this->fragmentShader);

	this->programID = glCreateProgram();

	glAttachShader(this->programID, this->vertexShaderID);
	glAttachShader(this->programID, this->fragmentShaderID);

	glLinkProgram(this->programID);

	GLint Result = GL_FALSE;
	int InfoLogLength = 1024;
	char ProgramErrorMessage[1024] = {0};

	glGetProgramiv(this->programID, GL_LINK_STATUS, &Result);
	glGetProgramiv(this->programID, GL_INFO_LOG_LENGTH, &InfoLogLength);
	glGetProgramInfoLog(this->programID, InfoLogLength, NULL, &ProgramErrorMessage[0]);
	std::cout << ProgramErrorMessage << "\n";
}

void Planet::render() {
	glUseProgram(this->programID);

	this->modelview = glm::mat4(1.0);//glm::rotate(glm::mat4(1.0), (glm::mediump_float) 22.5, glm::vec3(0.0,1.0,0.0));
	this->projection = glm::perspective(70.0, (double) 1 , 1.0, 100.0);
	

	glBindVertexArray(this->VAO);
		glEnable(GL_DEPTH_TEST);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

		glUniformMatrix4fv(glGetUniformLocation(this->programID, "modelview"), 1, GL_FALSE, glm::value_ptr(this->modelview));
		glUniformMatrix4fv(glGetUniformLocation(this->programID, "projection"), 1, GL_FALSE, glm::value_ptr(this->projection));

		glDrawArrays(GL_TRIANGLES,0,this->vertex_number * this->vertex_size);
	glBindVertexArray(0);
	glUseProgram(0);

}

void Planet::initVertex() {	
	this->vertex_array = new float[this->vertex_number * this->vertex_size];
	float alpha = 2.356194;
	//Create on the fly upper and lower triangles
	
	for (int i=0; i < 4; i++) {
		//Upper Triangles
		this->vertex_array[i*9]		= 0.5f * cos(alpha +  (i * (PI / 2)) );
		this->vertex_array[i*9+1]	= 0.5f * sin(alpha +  (i * (PI / 2)) );
		this->vertex_array[i*9+2]	= 0.0f;

		this->vertex_array[i*9+3]	= 0.5f * cos(alpha + ((i+1) * (PI / 2)) );
		this->vertex_array[i*9+4]	= 0.5f * sin(alpha + ((i+1) * (PI / 2)) );
		this->vertex_array[i*9+5]	= 0.0f;

		this->vertex_array[i*9+6]	= 0.0f;
		this->vertex_array[i*9+7]	= 0.0f;
		this->vertex_array[i*9+8]	= 0.5f;
		//Lower Triangles
		this->vertex_array[i*9+36]	= this->vertex_array[i*9];
		this->vertex_array[i*9+37]	= this->vertex_array[i*9+1];
		this->vertex_array[i*9+38]	= 0.0f;

		this->vertex_array[i*9+39]	= this->vertex_array[i*9+3];
		this->vertex_array[i*9+40]	= this->vertex_array[i*9+4];
		this->vertex_array[i*9+41]	= 0.0f;

		this->vertex_array[i*9+42]	= 0.0f;
		this->vertex_array[i*9+43]	= 0.0f;
		this->vertex_array[i*9+44]	= -0.5f;
	}
} 

int main(void) {
	GLFWwindow* window;

	if (!glfwInit())
		exit(-1);

	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);
	window = glfwCreateWindow(320, 320, "Procedural Planet", NULL, NULL);

	if (!window){
		glfwTerminate();
		exit(-1);
	}

	glfwMakeContextCurrent(window); 

	if(gl3wInit() != 0) {
		std::cout << "gl3w fail\n";
		return 0;
	};
	std::cout << glGetString(GL_VERSION) << "\n";
	
	Planet planet = Planet();

	while (!glfwWindowShouldClose(window)) {
		usleep( 40 * 1000 );
		planet.render();
		glfwSwapBuffers(window);
	}

	glfwDestroyWindow(window);

	glfwTerminate();

	exit(EXIT_SUCCESS);
}
